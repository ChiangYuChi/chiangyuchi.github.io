<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Hexo</title><meta name="description"><meta name="generator" content="Hexo"><meta name="author" content="John Doe"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="Hexo" title="Hexo" itemprop="headline">Hexo</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><h4 class="page-title">Recent Articles</h4><a href="/2019/06/25/2019-06-25/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Git 基本指令</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">常用終端機指令$ pwd (print working directory 印出現在所在位置)$ mkdir hello (make dir 建立目錄 hello)$ cd hello/（change dir 移動到目錄 hello）$ cd .. (回到上一層目錄)$ touch index.html (建立檔案 index.html)$ ls (列出目錄裡所有檔案)$ ls -al (列出目錄裡所有檔案的細節)$ rm index.</p></article></a><a href="/2019/06/24/2019-06-24/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">如何條列化思考</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這篇是 Hulo的線上免費課程初心者的計概與 coding 火球術，提供給我這種入門新手的程式思維思考心法。第二堂課的主題是「解決問題」，關注的方向式關於如何在日常思維與電腦化思維之間切換。在第一堂課之後，開始要練習一個可以深入學習的工程師思維，這需要不斷地問自己「為什麼？」另外，到底為什麼要寫程式呢？因為我們要用電腦話讓電腦照著我的意思做。要讓電腦聽話，那就要使用程式碼。最後，程式碼的目標，就是為了解決問題。
如何條列化思考？如何解決</p></article></a><a href="/2019/06/23/2019-06-23/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Get API 實作</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一篇主要是整理一個 Get API 小作品的思路。因為是參考別人的解法，加上自己的思考慣性是習慣從頭到尾把細節了解一次才認為完整掌握，所以使用這種看起來笨笨的步驟，一句一句拆解。
完成品 [https://chiangyuchi.github.io/get-api/]原始碼 [https://github.com/ChiangYuChi/get-api]
設定 DOM
select  區域選單
degreetable 
placeTi</p></article></a><a href="/2019/06/22/2019-06-22/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day27-函數陳述句與函數表示式</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">了解函數就是物件後，接著要實際運用這個觀念。開始之前，我們要先了解函數陳述句 （Function Statements) 與函數表示式 (Function Expressions) 的用法差異。
表示式
表示式是程式碼的單位，會形成一個值  (A unit of code that results in a value)

直接地說，任何表示式最終都會創造一個值，而這個值不一定要儲存在某個變數。
舉例來說，我們宣告一個變數 a，並且打開</p></article></a><a href="/2019/06/20/2019-06-20/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day26-函數就是物件</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">在這堂課裡面，作者說明 JavaScript 當中一個重要的觀念「一級函數」（first class functions)，也提到函數也是一種物件 (functions are object)。
一級函數 （First class functions)一級函數是指說：你可以對別的型別像是物件、字串、數值、布林做的事情，都可以對函數做。

你可以指派一個變數的值為函數
你可以把函數當做參數傳入另一個函數
可以用實體語法立刻創造函數。
函數</p></article></a><a href="/2019/06/19/2019-06-19/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day25 - JSON 與物件實體</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一節要繼續學習物件實體，還有一些使用 JSON 的時候經常遇到的誤解。JSON (avaScript物件表示法；JavaScript Object Notation) ，受到 JavaScript 物件實體語法啟發，看起來和物件實體語法非常類似，所有常常被誤認為是同一個東西，所以遇到同樣的錯誤。
JSON (avaScript物件表示法；JavaScript Object Notation)如果我建立一個物件實體，假設它有很多屬性，這</p></article></a><a href="/2019/06/16/2019-06-16/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day24-框架小叮嚀：偽裝命名空間</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一節是關於打開知名的框架原始碼經常會看到的東西。前面討論的那些主題，像是運算子、物件實體語法後，現在要學習偽裝命名空間 （faking namespaces)。
變數之間的衝突在現代的程式語言，命名空間是變數和函數的容器，只是一個包裝物、一個容器。通常這是用來分開那些有著相同名稱的函數和變數。
在 JavaScript 裡，因為物件的本質，不需要命名空間這個功能，所以並沒有命名空間，但可以假裝。
1234var greet =&amp;apo</p></article></a><a href="/2019/06/15/2019-06-15-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day22-物件與「點」</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">在 JavaScript 中，物件與函式兩者是非常相關的，它們在很多情況下幾乎是一樣的，讓我們從本篇之後來談談物件與函式，但在這之前得先了解本篇標題「物件與點」
物件與「點」一個物件是被賦值的名稱與值的組合（Name/Value），但是這個值是什麼？所以物件可以有一個原始的設定叫做屬性 (primitive property)，例如前面提到的純值、布林或字串；或者物件可以再連結另外的物件，值可以是另一個「名稱/值」的組合或物件。物件裡還</p></article></a><a href="/2019/06/15/2019-06-15-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day23-物件與實體</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">建立物件的捷徑在 JavaScript 裡面，完成一件事情還有許多方式，還記得宣告 new object 並非建立物件的最好方式，有一種建立物件的捷徑是利用大括號 {} 的物件實體語法（object literal syntax)，得到的結果會和 new object 一樣。
12var person = &amp;#123;&amp;#125;;console.log(person);

如果我列印出 person，會看到一個空物件，就像 new o</p></article></a><a href="/2019/06/07/2019-06-07/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JS 30 Days AJAX Type Ahead</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">利用 Fetch API 取得數據資料利用 fetch 取得數據資料的時候會先回傳 promise 給我們。Promise 是一個根據附加給他的 Callback 回傳的物件，以取代傳遞 Callback 到這個函數。它回傳的還不是我們要的資料。
查詢一下：
12const prom = fetch(endpoint);console.log(prom);


關於 promisehttps://developer.mozilla.or</p></article></a><a href="/2019/06/06/2019-06-06-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">calc()</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">calc() 這個 function 需要傳入 1 個加減乘除的運算式，在設定 width、height 這種  相關的屬性時， 在不同單位間也可以進行運算，如剛剛上面的範例：width: calc(100% - 50px);。calc() 的運算式一樣是按照先乘除後加減進行計算，如果需要進行複雜的運算，在 calc() 裡面也可以再加入括號 ()，就可以設為括號先決裡面的先算。

+：加
-：減
*：乘。其中一個運算參數必須是數字 (</p></article></a><a href="/2019/06/06/2019-06-06-3/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day21-框架小叮嚀：預設值</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">有時候我們會同時在專案匯入好幾個框架

1234//在 lib1.js設定一個變數var libraryName = &amp;quot;lib1&amp;quot;;`

12//在 lib2.js設定一個同樣名稱的變數var libraryName = &amp;quot;lib1&amp;quot;;

當我們回到 app.js 查詢 console.log的時候，這時三個 script 標籤並不會創造新的執行環境，而是直接把程式碼堆在對方上面，然後執行所有的 </p></article></a><a href="/2019/06/06/2019-06-06-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">let 與 const 的差異</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">let 與 const 用來宣告區塊裡的變數。區塊＝{}。
const 是用來宣告不能修改的唯讀變數，不能被變更的變數，例如 url 網址。 但是如果const宣告的變數是一個陣列或物件，則裡面的內容就能夠被修改。為了避免這種狀況，可以利用以下組合式語法：
12345const obj =&amp;#123;url:&amp;apos;http://xx.com&amp;apos;&amp;#125;;obj.freeze(obj);

要注意以下用法：
一、向上提昇</p></article></a><a href="/2019/06/05/2019-06-05/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">AJAX</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">AJAXAJAX並非是一個技術（Technology），而是一種網站設計的架構（Architecture），雖然主要以JavaScript與XML為主，但還包括其它成員，也就是CSS、DOM（Document Object Model）與HTML等，特別是XMLHttpRequest元件，使AJAX能達到非同步資料交換的目的。
在Jesse Garrett的文章中，對AJAX的定義如下：
● 使用XHTML與CSS作為展現標準● 使用D</p></article></a><a href="/2019/06/04/2019-06-04-3/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day20-預設值</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">運算子的強制型轉特性，在一些框架或JS程式裡究竟有什麼比較常見的用處？
12345function greet(name) &amp;#123;    console.log(&amp;apos;hello&amp;apos; + name);&amp;#125;greet();

假使呼叫 greet的時候 沒有參數，在 Javascript 並不會報錯，它會當做name 沒有東西。所以如果 console.log(name) 
123456function gre</p></article></a><a href="/2019/06/04/2019-06-04-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JS 30 Days Flex Panels Image Gallery</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">使用 CSS Flex
最外層的父元素 display 要設定為 flex 才會產生作為一個container容器的效果

設定子元素在畫面上都佔據一樣大小，並且將它設定為另一個container。
Flex 是可以嵌套的，也就是 flex container 可以同時是其他 flex container 的 flex item。

設定translate文字將會在 Y 軸的上下點擊動態隱藏或出現

中間的文字將會在點擊時動態放大
綁定</p></article></a><a href="/2019/06/04/2019-06-04-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JS 30 Days Array Cardio 1</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一天的課程主要說明運用 Array 是 Javascript 很重要的環節，像是 filter、map、sort、reduce。
範例 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const inven</p></article></a><a href="/2019/06/03/2019-06-03/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day19-存在與布林</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">動態型別和強制型轉到底有什麼功能？

以上這些東西都表示不存在，所以被布林轉換成false。然而，這些特性是可以利用的嗎？
12345var a; if (a) &amp;#123;    console.log(&amp;apos;something is there&amp;apos;);&amp;#125;

宣告var a 但不設值
在陳述句括號裡的東西，會轉換成布林，所以a是什麼不重要。如果 a 是上述三個任何一種，那麼這個if陳述句會不成立，因為a不存在。</p></article></a><a href="/2019/06/02/2019-06-02-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">map() 和 forEach() 的差別在哪？</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">兩種方法都會遍歷陣列的元素。map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。但是forEach不會建立新陣列，只會將原先陣列內的每個元素，皆傳入並執行給定的函式一次。
123456789var array1 = [&amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;apos;c&amp;apos;];array1.forEach(function(element) &amp;#123;  c</p></article></a><a href="/2019/06/02/2019-06-02-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day18-比較運算子</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">
以上的小於運算子範例，我們會預設結果為true
但是這個例子竟然也是 true ? 這可以用運算子優先性和相依性來解釋。這兩個運算子的優先性一樣，所以用相依性來決定執行順序，所以相依性是從左到右，左邊先執行。所以是 3&amp;lt;2 先執行，並且得出false。

接下來，因為運算子遇到兩個不同型別的比較，這裡是一個布林值與數字，所以布林被強制型轉為數字。

我們可以用內建函數查詢，發現 false 被型轉為數字 0。所以 0&amp;lt;1 </p></article></a><a href="/2019/06/01/2019-06-01/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day17-強制型轉</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 是一種動態型別語言（Dynamic Typing），所以強制型轉也是常見的情況。
強制型轉(Coercion) 也就是轉換一個值的型別，例如數值型別轉換成字串。
舉例來說：先前我們已經知道運算子是一種特殊的函數，需要傳入2個參數，並且回傳1個值。
12var a=1+2;console.log(a);

出現正常的結果3

但是以下傳入2個不同型別的參數，卻出現 12，發生什麼事？
12var a=1+&amp;apos;</p></article></a><a href="/2019/05/31/2019-05-31-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day16-運算子的優先性與相依性</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">了解運算子後，繼續了解運算子的優先性與相依性。這兩個概念沒有想像中的複雜。
運算子優先性運算子優先性表示當一行程式碼裡面有多個運算子的時候，哪個運算子被優先運算，函數會依序運算。具有高優先性的運算子，會先計算，然後依序到低優先性的
運算子相依性運算子相依性是和運算子優先性相關的概念，優先性表示運算子被計算的順序，當兩個運算子有相同的優先性，優先性能協助判斷誰先誰後。可是如果所有的運算子優先順序都相同呢？
這時就要看相依性，判斷是由左到右</p></article></a><a href="/2019/05/31/2019-05-31-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">console.log 得出什麼值？ Hoisting 觀念</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">123456var foo = 1var foobar = function() &amp;#123;  console.log(foo)  var foo = 2&amp;#125;foobar()

由於提昇的作用，儘管區域變數 foo 的宣告會先於呼叫console.log方法，也就是 區域變數的值將會作為參數傳入成為 console.log得出的值，而不是在函數外部聲明的全域變數。
但是，由於變數宣告不會提升該值，因此輸出將是undefined</p></article></a><a href="/2019/05/29/2019-05-29/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day14-純值</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 有六種基本型別 （Primitive types)，表示一個值，它不是物件，因為物件是名稱與值的配對。因此基本型別，就只是一個值。
Javascript 的六種基本型別包括

undefined：表示還不存在，是Javascript給所有變數的初始值，直到你賦與變數一個值。所以不應該設定一個值為undefined，因為這就表示這個變數還沒被設定任何的值。

null: null 也表示不存在。因為undefined</p></article></a><a href="/2019/05/29/2019-05-30/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day15-運算子</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">運算子是一種特殊的函數，它和其他你自己寫的函數不同。運算子需要 2 個參數來回傳一個結果。但是Javascript是怎樣處理運算符號呢？
12var a = 3+4;   console.log(a); /會得出變數值為7/

Javascript在底層運作時，其實把運算子也等同於一種型態的函式。例如加法，它宣告一個函式，但不是命名它為 add 
123function +(a,b)&amp;#123;return // 兩數相加&amp;#125;
</p></article></a><a href="/2019/05/27/2019-05-27/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">用 Vue 做一個 Todolist</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">首先我們要設定一個 Todo List 的基礎結構，包括新增項目的輸入框、點擊把資料加入vue原始碼的按鈕、以陣列儲存資料內容的區段，因此我們以v-for動態產生資料於畫面上。todos 用來儲存所有待辦事項內容
STEP 1 建立待辦事項的列表
123456789101112131415161718192021222324&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;</p></article></a><a href="/2019/05/23/2019-05-23/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day13-型別與 JavaScript</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 在變數的資料型別方面與其他的程式語言相當不同，它是以「動態型別」（Dynamic Typing) 處理資料型別，它能夠辨別數值、字串和布林值。亦即我們不用自己在程式裡告知 Javascript   變數是哪種型別的資料，它會在程式執行運行時主動判別。因此一個變數可以在執行程式的不同階段，擁有不同的型別，因為型別都是在執行時才判別的。
動態型別是說不用任何關鍵字宣告變數的型別，程式執行的時候，它會自己判別要給這個變數</p></article></a><a href="/2019/05/20/2019-05-20/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day12-關於非同步回呼</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">非同步的意思是在一個時間點不只一個，可能有一段程式碼在執行時會開始執行另一段程式碼，繼而再執行別的程式碼，這些程式碼在 Javascript 引擎內是同時在執行的。
雖然 Javascript 是同步的（synchronous) ，它不會非同步的執行，一次執行一行程式碼。然而像是點擊事件或是從 Javascript 取得資料，有 callback 函數可以執行，當事件或動作完成，因為 Javascript 是同步的，會怎麼處理非同步事件</p></article></a><a href="/2019/05/19/2019-05-19/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day11-範圍、ES6 與 let</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">執行環境、變數環境與詞彙環境定義了所謂的範圍，特別是在範圍鏈當中可看到每個函數都有一個外部環境。
簡短來說，範圍就是變數可以被取用的區域。如果有兩個相同變數，如果呼叫相同函數2次，它會各有一個自己的執行環境，這兩個看起來相同的變數，在記憶體中其實是兩個不同的變數。
在ES6當中，引進一種新的宣告變數方法 let。雖然它的使用方法與var相同，但並沒有取代後者。但是 let 讓 Javascript 引擎使用「區塊範圍」（block sc</p></article></a><a href="/2019/05/17/2019-05-17/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day10-範圍鏈</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">當我們需要使用變數時，JS 不只會在目前的執行環境的變數環境尋找。因為每個執行環境都會創造一個特殊的變數叫做this 以及外部環境的參照。每個執行環境都有一個參照到他的外部環境。 
1234567891011function b() &amp;#123;	console.log(myVar);&amp;#125;function a() &amp;#123;	var myVar = 2;	b();&amp;#125;var myVar = 1;a();

在函數b的狀</p></article></a><a href="/2019/04/27/2019-04-27/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript 地下城 - Clock</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">完整程式碼
https://github.com/ChiangYuChi/clock
完成範例https://chiangyuchi.github.io/clock/
一開始不太知道要怎麼動手，所以就先做出背景。HTML的結構如下：

首先我們先把時鐘的底放好

接著要開始做鐘面，這裡分為兩個部分進行，這兩層的作法是類似的：

12小時及橘色的區間
60分鐘及白色小點

先設定數字及中間橘色的分隔線先以中上的24-12為基準點並且用fo</p></article></a><a href="/2019/04/22/2019-04-22/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day9-函數、環境與變數環境</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">變數環境(variable environments) 是另一個理解Javascript底層運作原理的基礎概念。變數環境就是指你創造變數的位置，以及他在記憶體中和其他變數的關係。因此在思考變數環境的時候，只要思考變數在哪裡？
12345678910111213function b() &amp;#123;	var myVar;   &amp;#125;function a() &amp;#123;	var myVar = 2;   	b();&amp;#125;var</p></article></a><a href="/2019/04/18/2019-04-18/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day8-函數呼叫與執行堆</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">全域執行環境的創造與執行和函數脫不了關係，函數呼叫與執行堆更是其中兩個重要環節。
在Javascript裡，當我們用括號（）執行或呼這個函數時，我們稱作 “invoke the function” 或 “function invocation”。「函數名稱＋（）」就要求Javascript呼叫了函數。但是JS呼叫函數時發生什麼事情？
12345678910function b() &amp;#123;   &amp;#125;function a()&amp;</p></article></a><a href="/2019/04/17/2019-04-17/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day7-單執行緒、同步執行</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">單執行緒(single threaded)和同步執行(synchronous execution)也是Javascript裡很重要的基礎觀念之一。
單執行緒表示：一次執行一個指令。因為在使用瀏覽器的時候，瀏覽器不只運作JS這個程式而已，因此當我們說JS是單執行緒的時候，不是指瀏覽器，而是從我們自己的角度來看，Javascript一次只做1件事情。
同步執行：和單執行緒有點類似，同步的意思是，對程式語言來說，一次一個而不是一次兩個或三個。</p></article></a><a href="/2019/04/15/2019-04-15/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day6-執行環境：程式執行</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript產生執行環境時，第一階段是創造，設定變數和函數到記憶體中。第二階段是執行。

上面的程式碼會得出什麼執行結果呢？

為什麼呢？ 因為現在已經是執行階段，首先先設定函數，接著變數a被設定為undefied。隨後開始執行程式碼，從第5行開始執行，它執行函數b，並輸出’called b’;接著執行第七行並輸出變數a到console，由於變數a在創造階段被設定為undefined，因此得出undefined; 第9行的變數a</p></article></a><a href="/2019/04/13/2019-04-13/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day5-Javascript 與 undefined</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">創造執行環境的第一階段「創造階段」，會在全域環境裡產生一個全域物件及一個特殊的變數 “this”；如果有外部環境，也會產生連結到外部環境的連結；以及「提昇」（hositing) 的特殊現象，為函數及變數在記憶體裡建立空間，此時變數的初始值被設定為 undefined。
undefined 是什麼意思呢？
12var a;console.log(a);

在瀏覽器查詢的結果會是undefined

 undefined 其實是一種Java</p></article></a><a href="/2019/04/12/2019-04-12/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day4-創造與提昇</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript執行時，會經過創造執行環境的階段，這時時會發生的什麼事情呢？
在下列的範例中，假如我們把呼叫移到程式碼最上方，移到函式之前。

在大部分的程式語言，會報錯，因為他們一次執行一行程式碼，而且還沒宣告b函數，所以呼叫是無效的。但JS不僅執行函數，而且沒有錯誤。

Called b!正常被印出來，代表函式b有正常執行，但是undefined呢? 
Javascript 程式碼在執行前，會經過一個階段，我們寫的東西並不是直接</p></article></a><a href="/2019/04/10/2019-04-10/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day2-觀念小叮嚀:名稱/值配對與物件</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">物件在Javascript當中非常重要，要明白物件的意義，首要必須釐清名稱/值的配對。
所以在任一個執行環境下，一段正在執行的程式碼，同樣名稱只會有一個，一個名稱只能被一個值定義。但是這個值，可能是更多名稱/值配對。總歸而言，一個名稱，只會被配對一個值
例如：
12345678Address:&amp;#123;    Street:&amp;apos;Main&amp;apos;,    Number: 100,    Apartment:&amp;#123;   </p></article></a><a href="/2019/04/10/2019-04-11/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day3-全域環境與全域物件</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript程式永遠都是在執行環境中運作，也就是透過解譯器（一個已經寫好的程式）驗證和執行你的程式碼。把你的程式碼包起來，把正在執行的程式碼包在執行環境裡面。所以我們第一次看Javascript程式時，看到的是執行環境被建立和執行。
而基礎的執行環境和其他被執行的程式碼不同，基礎執行環境是全域執行環境。所謂全域，即是指可以在任何地方取用他。
即便一個Javascript檔案裡還沒有寫入任何程式碼、空的，只要一旦載入，語法解析器開</p></article></a><a href="/2019/04/01/2019-04-01/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 Day1-觀念小叮嚀:語法解析器、執行環境、詞彙環境</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">要理解 JavaScript 的運作原理，包含三項最基本的觀念

語法解析器(Syntax Parsers)
執行環境(Execution Contexts)
詞彙環境(Lexical Environments)

語法解析器語法解析器是什麼？在寫Javascript程式碼時，假使語法是有效的，程式碼可被讀取並且執行，並非是程式碼直接告訴電腦如何執行，而是透過別人寫的另一個程式（解譯器），把你寫的Javascript程式碼，逐字解讀成電</p></article></a><a href="/2018/04/01/hello-world/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Hello World</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Welcome to Hexo!  [連結]（https://www.google.com)！ This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on Gi</p></article></a></main></body></html>