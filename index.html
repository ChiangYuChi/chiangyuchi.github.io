<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>CYC'S BLOG</title><meta name="description"><meta name="generator" content="CYC'S BLOG"><meta name="author" content="John Doe"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="CYC'S BLOG" title="CYC'S BLOG" itemprop="headline">CYC'S BLOG</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><h4 class="page-title">Recent Articles</h4><a href="/2019/09/22/2019-09-22/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript 練習 - Simple Rolling-Dice Game</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">DemoJavaScript 練習 - Rolling Dice Game - Demo
1. Introduction 介紹這是 Udemy 上的課程的一個小遊戲，操作 click 事件，並搭配判斷式切換玩家，以及新增 class，實現擲骰子遊戲。


以判斷式當擲出 1，則切換玩家，並且此輪不累積分數
當連續擲出 2 個 6 的時候，判定兩方誰目前累積的所有分數歸零
可儲存該輪暫存分數到總分裡
需判定誰達到勝利標準
可由玩家輸入自</p></article></a><a href="/2019/08/09/2019-08-23-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day36] - 立即呼叫的函數表示式 (IIFEs)</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">立即呼叫的函數表示式（immediately invoked function expression, IIFEs) 是一個常用的簡潔觀念。
先前我們已經知道函數陳述句和函數表達式的差異
函數陳述句123456function greet(name)&amp;#123;console.log(&amp;apos;Hello&amp;apos; + name);&amp;#125;greet();

JavaScript 即便把函數放到記憶體中還是不會執行任何東西，除非</p></article></a><a href="/2019/08/06/2019-08-23-3/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">認識 Webpack</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Webpack 是一個開源的前端打包工具。Webpack 提供了前端開發缺乏的模組化開發方式，將各種靜態資源視為模組，並從它生成最佳化過的程式碼。
安裝並開一個新的 webpack
安裝套件在 webpack 裡
透過 sass 載入 bootstrap 4
vue-axios ，一個 ajax 工具

因為 sass 在 vue cli 沒有安裝完整的 loader 所以這裡要再安裝 node-sass 、sass-loader

安</p></article></a><a href="/2019/08/02/2019-08-23-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day33] - 觀念小叮嚀 語法解析器</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">我們要再一次熟悉語法解析器，因為這對後面認識底層知識十分重要。
已經知道我們寫的程式碼不會直接被電腦執行，而是有一個在程式碼和電腦中間中介的程式，轉換你的程式為電腦懂的東西。這就是瀏覽器裡的 JavaScript 引擎做的事情，其中之一就是語法解析器。
語法解析器會閱讀程式碼，判斷這是否有效。如果它一個一個字看程式碼，看到 ‘r’，它假設你可能要輸入的是 ‘return’，所以它會預期再看到一個 ‘e’，它會一個一個字進行。如果它看到一</p></article></a><a href="/2019/07/16/2019-08-23-4/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [8] - Vue Router</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">使用 Vue Router 及配置路由文件//進入點main.js//Router 配置檔案 (前端路由，決定哪個網址讀取哪個元件。假如在新建 Vue cli 的時候選擇需要包含 router 配置，就會直接建立在這個目錄下面)router/index.js//分頁內容Vue components (**.vue)
安裝npm install vue-router --save概念描述Vue-router 是 Vue.js 的官方路由插</p></article></a><a href="/2019/07/15/2019-07-15-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [7] - 用 Vue 做一個 Todolist</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">完成品 https://chiangyuchi.github.io/vue-simple-todolist/原始碼 https://github.com/ChiangYuChi/vue-simple-todolist
原始 HTML 結構有一個 input 欄位，現在要在輸入後把文字加入代辦事項列表，首先設定一個代辦事項列表的基礎結構，包括：

新增項目的輸入框、
點擊後把資料加入vue原始碼的按鈕
以陣列儲存資料內容的區段

我們以 </p></article></a><a href="/2019/07/14/2019-07-14-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day32] - 框架小叮嚀：重載函數</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一節是關於框架或資源庫的應用。首先要了解的是為什麼 JavaScript 去掉一些其他程式語言的特性，這些特性又為何不重要。
重載函數 (Function overloading)像是 Java、C++ 等程式語言都有重載函數的概念，這表示我讓同一個函數可以擁有不同數量的參數。但是這在 JavaScript 行不通，因為函數就是物件。儘管 JavaScript 不具備這個功能，但是我們也可以用 JavaScript 的一級函式概念處理</p></article></a><a href="/2019/07/14/2019-07-14-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [6] - 表格排序練習</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">表格排序練習

v-on
v-if
v-class
computed

完成品 https://codepen.io/Shengzhi/pen/RmbMLw
</p></article></a><a href="/2019/07/13/2019-07-13-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day31]-argument 與 spread</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一節是是關於另一個 JavaScript 的關鍵字「參數 (arguments)」，這是在執行一個函式的時候引擎會自動幫我們設定好的關鍵字。雖然在下一版本的 JavaScript 就不會這麼常提到這個關鍵字，而是用 spread 處理 arguments 的工作。但是如果現在去看任何程式碼，尤其是框架和資源庫，還是會在原始碼看到 arguments 變數。所以我們應該要認識及知道它的用處。
已知執行函數的時候，一個執行環境被創造，然後</p></article></a><a href="/2019/07/12/2019-07-12-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day30]-觀念小叮嚀：陣列--任何東西的集合</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">陣列是包含許多東西的集合，陣列可以被宣告，例如：
1var arr = new Array();

或者使用陣列實體語法，和物件實體語法類似，除了它是用中括號而不是大括號。放進我要的值，並且在陣列裡面用逗號分隔。
12var arr = [1,2,3];arr[2];

陣列索引值從 0 開始，所以我可以用中括號決定我要抓出哪一個值。2 是第三個值，以此類推。這對以其他程式語言處理陣列的人來說，似乎沒什麼需要解釋的地方。但因為 Java</p></article></a><a href="/2019/07/12/2019-07-12-3/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [5] - 動態切換 ClassName 及 Style 多種方法</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">假設我們要在原始 HTML 結構上動態為 .box 動態加上 className “rotate”
物件寫法
v-bind 綁定一個 class，附加一個物件，但因為是物件的關係，所以可以插入一個以上的值HTML 部份

12345678&amp;lt;div class=&amp;quot;box&amp;quot; :class=&amp;quot;&amp;#123;&amp;apos;rotate&amp;apos;:isTransform,&amp;apos;bg-danger&amp;apos;</p></article></a><a href="/2019/07/11/2019-07-11-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [4] - 元件基礎概念</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Vue 的每一個元件都可以獨立儲存各自的狀態，以下是一個元件的範例，此範例以反引號來定義元件
123456789101112131415161718192021&amp;lt;script&amp;gt;          // 請在此撰寫 JavaScript          Vue.component(&amp;apos;counter-component&amp;apos;, &amp;#123;            data: function () &amp;#123;</p></article></a><a href="/2019/07/10/2019-07-10-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [3] - 常見表單與資料的綁定方式</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">使用 v-model 綁定 input 輸入字串12345678910111213141516171819&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;          &amp;lt;h4&amp;gt;字串&amp;lt;/h4&amp;gt;          &amp;#123;&amp;#123; text &amp;#125;&amp;#125;          &amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;form-contr</p></article></a><a href="/2019/07/09/2019-07-10-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [2] - methods、computed、watch 的使用情境</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">computed
computed 方法，會將結果直接回傳存到變數裡面，而且這個變數可以直接使用在畫面上。在 computed 內的任何屬性都是 function 。 原始 data 結構的值若更動時，computed 裡面的值才會跟著更動。- computed 是在監控資料更動後，重新運算結果呈現於畫面上，一般來說不會修改資料，只會回傳用於畫面呈現的資料。- methods 就是互動的函式，需要觸發才會運作會用來修改資料內容

met</p></article></a><a href="/2019/07/09/2019-07-09/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Vue 基礎概念 [1] - 環境建立、指令與修飾符</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">環境建立Vue 的載入有 2 個版本，可以使用官網提供的CDN快速引入：
開發版本- 包含開發者工具、完整的警告、錯誤提示，適合開發時使用生產版本- 刪除了警告，將上述開發工具都拔除，盡量縮小它的體積，適合正式發布時使用。
為了學習 Vue 的開發，因此我們選擇開發版本，並且在 script 標籤引入 vue.js 即可。
12345678&amp;lt;head&amp;gt;&amp;lt;script src=&amp;quot;https://cdn.jsde</p></article></a><a href="/2019/07/08/2019-07-08/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day29] - 物件、函數與 this</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">函數是一種物件，具有屬性及其他特徵。回到執行環境來看，在函數被呼叫的時候，底層究竟發生什麼變化呢？ 現在要繼續深究物件、函數以及有時讓人感到困惑的關鍵字 ”this” 之間的關係。
當函式被呼叫的時候必須放在心中的是，當函數被呼叫的時候，會創造新的執行環境，放進執行堆，這決定了程式的執行方式。如果想一想執行環境，關注在函數物件的程式部分，當我執行程式屬性裡面的程式會怎麼樣？
我們知道執行環境被創造的時候，每個執行環境有自己的變數環境</p></article></a><a href="/2019/06/29/2019-06-29/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day28] - 傳值與參考值</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一節又來到另一個重要觀念「傳值（by value)」與「參考值(by reference)」，這兩者都和變數關係密切。
傳值好比說有一種純值（primitive value)，可能是數字、布林或字串。我設定一個值到這個變數中，變數就有一個位址，它知道那個純值的記憶體位址。因為參考是參照到一個記憶體的位址。

設定一個新變數，設定它等於 a，也可以說是我傳入 a 到一個函數，兒這個函數的名稱是 b。如果這是 JavaScript 中的純</p></article></a><a href="/2019/06/25/2019-06-25/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Git 基本指令</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">常用終端機指令$ pwd (print working directory 印出現在所在位置)$ mkdir hello (make dir 建立目錄 hello)$ cd hello/（change dir 移動到目錄 hello）$ cd .. (回到上一層目錄)$ touch index.html (建立檔案 index.html)$ ls (列出目錄裡所有檔案)$ ls -al (列出目錄裡所有檔案的細節)$ rm index.</p></article></a><a href="/2019/06/24/2019-06-24/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">如何條列化思考</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這篇是 Hulo的線上免費課程初心者的計概與 coding 火球術，提供給我這種入門新手的程式思維思考心法。第二堂課的主題是「解決問題」，關注的方向式關於如何在日常思維與電腦化思維之間切換。在第一堂課之後，開始要練習一個可以深入學習的工程師思維，這需要不斷地問自己「為什麼？」另外，到底為什麼要寫程式呢？因為我們要用電腦話讓電腦照著我的意思做。要讓電腦聽話，那就要使用程式碼。最後，程式碼的目標，就是為了解決問題。
如何條列化思考？如何解決</p></article></a><a href="/2019/06/23/2019-06-23/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Get API 實作</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一篇主要是整理一個 Get API 小作品的思路。因為是參考別人的解法，加上自己的思考慣性是習慣從頭到尾把細節了解一次才認為完整掌握，所以使用這種看起來笨笨的步驟，一句一句拆解。
完成品 https://chiangyuchi.github.io/get-api原始碼 https://github.com/ChiangYuChi/get-api
設定 DOM
select  區域選單
degreetable 
placeTitle 區</p></article></a><a href="/2019/06/22/2019-06-22/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day27] - 函數陳述句與函數表示式</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">了解函數就是物件後，接著要實際運用這個觀念。開始之前，我們要先了解函數陳述句 （Function Statements) 與函數表示式 (Function Expressions) 的用法差異。
表示式
表示式是程式碼的單位，會形成一個值  (A unit of code that results in a value)

直接地說，任何表示式最終都會創造一個值，而這個值不一定要儲存在某個變數。
舉例來說，我們宣告一個變數 a，並且打開</p></article></a><a href="/2019/06/20/2019-06-20/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day26] - 函數就是物件</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">在這堂課裡面，作者說明 JavaScript 當中一個重要的觀念「一級函數」（first class functions)，也提到函數也是一種物件 (functions are object)。
一級函數 （First class functions)一級函數是指說：你可以對別的型別像是物件、字串、數值、布林做的事情，都可以對函數做。

你可以指派一個變數的值為函數
你可以把函數當做參數傳入另一個函數
可以用實體語法立刻創造函數。
函數</p></article></a><a href="/2019/06/19/2019-06-19/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day25] - JSON 與物件實體</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一節要繼續學習物件實體，還有一些使用 JSON 的時候經常遇到的誤解。JSON (avaScript物件表示法；JavaScript Object Notation) ，受到 JavaScript 物件實體語法啟發，看起來和物件實體語法非常類似，所有常常被誤認為是同一個東西，所以遇到同樣的錯誤。
JSON (avaScript物件表示法；JavaScript Object Notation)如果我建立一個物件實體，假設它有很多屬性，這</p></article></a><a href="/2019/06/16/2019-06-16/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day24] - 框架小叮嚀：偽裝命名空間</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一節是關於打開知名的框架原始碼經常會看到的東西。前面討論的那些主題，像是運算子、物件實體語法後，現在要學習偽裝命名空間 （faking namespaces)。
變數之間的衝突在現代的程式語言，命名空間是變數和函數的容器，只是一個包裝物、一個容器。通常這是用來分開那些有著相同名稱的函數和變數。
在 JavaScript 裡，因為物件的本質，不需要命名空間這個功能，所以並沒有命名空間，但可以假裝。
1234var greet =&amp;apo</p></article></a><a href="/2019/06/15/2019-06-15-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day23] - 物件與實體</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">建立物件的捷徑在 JavaScript 裡面，完成一件事情還有許多方式，還記得宣告 new object 並非建立物件的最好方式，有一種建立物件的捷徑是利用大括號 {} 的物件實體語法（object literal syntax)，得到的結果會和 new object 一樣。
12var person = &amp;#123;&amp;#125;;console.log(person);

如果我列印出 person，會看到一個空物件，就像 new o</p></article></a><a href="/2019/06/15/2019-06-15-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day22] - 物件與「點」</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">在 JavaScript 中，物件與函式兩者是非常相關的，它們在很多情況下幾乎是一樣的，讓我們從本篇之後來談談物件與函式，但在這之前得先了解本篇標題「物件與點」
物件與「點」一個物件是被賦值的名稱與值的組合（Name/Value），但是這個值是什麼？所以物件可以有一個原始的設定叫做屬性 (primitive property)，例如前面提到的純值、布林或字串；或者物件可以再連結另外的物件，值可以是另一個「名稱/值」的組合或物件。物件裡還</p></article></a><a href="/2019/06/07/2019-06-07/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JS 30 Days - AJAX Type Ahead</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">利用 Fetch API 取得數據資料利用 fetch 取得數據資料的時候會先回傳 promise 給我們。Promise 是一個根據附加給他的 Callback 回傳的物件，以取代傳遞 Callback 到這個函數。它回傳的還不是我們要的資料。
查詢一下：
12const prom = fetch(endpoint);console.log(prom);


關於 promisehttps://developer.mozilla.or</p></article></a><a href="/2019/06/06/2019-06-06-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">calc()</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">calc() 這個 function 需要傳入 1 個加減乘除的運算式，在設定 width、height 這種  相關的屬性時， 在不同單位間也可以進行運算，如剛剛上面的範例：width: calc(100% - 50px);。calc() 的運算式一樣是按照先乘除後加減進行計算，如果需要進行複雜的運算，在 calc() 裡面也可以再加入括號 ()，就可以設為括號先決裡面的先算。

+：加
-：減
*：乘。其中一個運算參數必須是數字 (</p></article></a><a href="/2019/06/06/2019-06-06-3/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day21] - 框架小叮嚀：預設值</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">有時候我們會同時在專案匯入好幾個框架

1234//在 lib1.js設定一個變數var libraryName = &amp;quot;lib1&amp;quot;;`

12//在 lib2.js設定一個同樣名稱的變數var libraryName = &amp;quot;lib1&amp;quot;;

當我們回到 app.js 查詢 console.log的時候，這時三個 script 標籤並不會創造新的執行環境，而是直接把程式碼堆在對方上面，然後執行所有的 </p></article></a><a href="/2019/06/05/2019-06-05/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">AJAX</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">AJAXAJAX並非是一個技術（Technology），而是一種網站設計的架構（Architecture），雖然主要以JavaScript與XML為主，但還包括其它成員，也就是CSS、DOM（Document Object Model）與HTML等，特別是XMLHttpRequest元件，使AJAX能達到非同步資料交換的目的。
在Jesse Garrett的文章中，對AJAX的定義如下：
● 使用XHTML與CSS作為展現標準● 使用D</p></article></a><a href="/2019/06/04/2019-06-04-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JS 30 Days - Flex Panels Image Gallery</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">完成品https://codepen.io/Shengzhi/pen/zQyZZv
使用 CSS Flex
最外層的父元素 display 要設定為 flex 才會產生作為一個container容器的效果

設定子元素在畫面上都佔據一樣大小，並且將它設定為另一個container。
Flex 是可以嵌套的，也就是 flex container 可以同時是其他 flex container 的 flex item。

設定translat</p></article></a><a href="/2019/06/04/2019-06-04-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JS 30 Days - Array Cardio 1</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">這一天的課程主要說明運用 Array 是 Javascript 很重要的環節，像是 filter、map、sort、reduce。
範例 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const inven</p></article></a><a href="/2019/06/04/2019-06-04-3/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day20] - 預設值</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">運算子的強制型轉特性，在一些框架或JS程式裡究竟有什麼比較常見的用處？
12345function greet(name) &amp;#123;    console.log(&amp;apos;hello&amp;apos; + name);&amp;#125;greet();

假使呼叫 greet的時候 沒有參數，在 Javascript 並不會報錯，它會當做name 沒有東西。所以如果 console.log(name) 
123456function gre</p></article></a><a href="/2019/06/03/2019-06-03/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day19] - 存在與布林</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">動態型別和強制型轉到底有什麼功能？

以上這些東西都表示不存在，所以被布林轉換成false。然而，這些特性是可以利用的嗎？
12345var a; if (a) &amp;#123;    console.log(&amp;apos;something is there&amp;apos;);&amp;#125;

宣告var a 但不設值
在陳述句括號裡的東西，會轉換成布林，所以a是什麼不重要。如果 a 是上述三個任何一種，那麼這個if陳述句會不成立，因為a不存在。</p></article></a><a href="/2019/06/02/2019-06-02-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day18] - 比較運算子</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">
以上的小於運算子範例，我們會預設結果為true
但是這個例子竟然也是 true ? 這可以用運算子優先性和相依性來解釋。這兩個運算子的優先性一樣，所以用相依性來決定執行順序，所以相依性是從左到右，左邊先執行。所以是 3&amp;lt;2 先執行，並且得出false。

接下來，因為運算子遇到兩個不同型別的比較，這裡是一個布林值與數字，所以布林被強制型轉為數字。

我們可以用內建函數查詢，發現 false 被型轉為數字 0。所以 0&amp;lt;1 </p></article></a><a href="/2019/06/02/2019-06-02-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">map() 和 forEach() 的差別在哪？</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">兩種方法都會遍歷陣列的元素。map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。但是forEach不會建立新陣列，只會將原先陣列內的每個元素，皆傳入並執行給定的函式一次。
123456789var array1 = [&amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;apos;c&amp;apos;];array1.forEach(function(element) &amp;#123;  c</p></article></a><a href="/2019/06/01/2019-06-01/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day17] - 強制型轉</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 是一種動態型別語言（Dynamic Typing），所以強制型轉也是常見的情況。
強制型轉(Coercion) 也就是轉換一個值的型別，例如數值型別轉換成字串。
舉例來說：先前我們已經知道運算子是一種特殊的函數，需要傳入2個參數，並且回傳1個值。
12var a=1+2;console.log(a);

出現正常的結果3

但是以下傳入2個不同型別的參數，卻出現 12，發生什麼事？
12var a=1+&amp;apos;</p></article></a><a href="/2019/05/31/2019-05-31-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day16] - 運算子的優先性與相依性</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">了解運算子後，繼續了解運算子的優先性與相依性。這兩個概念沒有想像中的複雜。
運算子優先性運算子優先性表示當一行程式碼裡面有多個運算子的時候，哪個運算子被優先運算，函數會依序運算。具有高優先性的運算子，會先計算，然後依序到低優先性的
運算子相依性運算子相依性是和運算子優先性相關的概念，優先性表示運算子被計算的順序，當兩個運算子有相同的優先性，優先性能協助判斷誰先誰後。可是如果所有的運算子優先順序都相同呢？
這時就要看相依性，判斷是由左到右</p></article></a><a href="/2019/05/29/2019-05-30/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day15] - 運算子</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">運算子是一種特殊的函數，它和其他你自己寫的函數不同。運算子需要 2 個參數來回傳一個結果。但是Javascript是怎樣處理運算符號呢？
12var a = 3+4;   console.log(a); /會得出變數值為7/

Javascript在底層運作時，其實把運算子也等同於一種型態的函式。例如加法，它宣告一個函式，但不是命名它為 add 
123function +(a,b)&amp;#123;return // 兩數相加&amp;#125;
</p></article></a><a href="/2019/05/29/2019-05-29/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">克服 JavaScript 的奇怪部份 [Day14] - 純值</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 有六種基本型別 （Primitive types)，表示一個值，它不是物件，因為物件是名稱與值的配對。因此基本型別，就只是一個值。
Javascript 的六種基本型別包括

undefined：表示還不存在，是Javascript給所有變數的初始值，直到你賦與變數一個值。所以不應該設定一個值為undefined，因為這就表示這個變數還沒被設定任何的值。

null: null 也表示不存在。因為undefined</p></article></a><a href="/2019/04/28/2019-04-28/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript 練習 - 九九乘法表</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">DemoJavaScript 練習 - 九九乘法表 - Demo
1. Introduction 介紹這是 六角學院的一個小挑戰，使用 JavaScript for 迴圈獲取九九乘法表所有內容。


使用 for 迴圈獲取九九成法表全部內容
不能將數字直接寫在 HTML 上，必須用 JavaScript 渲染

2. 功能12345678910&amp;lt;div class=&quot;wrap&quot;&amp;gt;  &amp;lt;div class=&quot;title&quot;</p></article></a><a href="/2019/04/27/2019-04-27/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript 練習 - 時鐘功能</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">DemoJavaScript 練習 - Clock - Demo
1. Introduction 介紹這是 六角學院的一個小挑戰，使用 JavaScript 原生語法獲取時間，並且讓時針持續轉動，實現時鐘功能。


使用 JavaScript 原生語法的 getDate() 獲取時間
使用 JavaScript 原生語法的 setInterval() 方式讓指針持續轉動。
使用 for 迴圈渲染出鐘面
以 nth-child(n) 改變</p></article></a><a href="/2019/04/26/2019-04-26/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (13) - 型別與 JavaScript</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">程式語言都具有資料結構，但在不同的程式語言之間會有些差異。Javascript 在變數的資料型別與其他的程式語言相當不同，它是以「動態型別」（Dynamic Typing) 處理資料型別。
動態型別JavaScript 是弱型別，也能說是動態的程式語言。這代表你不必特別宣告變數的型別。程式在運作時，型別會自動轉換。這也代表你可以以不同的型別使用同一個變數。它能夠辨別數值、字串和布林值。亦即我們不用自己在程式裡告知 Javascript </p></article></a><a href="/2019/04/25/2019-04-25/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (12) - 關於非同步回呼</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">非同步的意思是在一個時間點不只一個，可能有一段程式碼在執行時會開始執行另一段程式碼，繼而再執行別的程式碼，這些程式碼在 Javascript 引擎內是同時在執行的。
雖然 Javascript 是同步的（synchronous) ，它不會非同步的執行，一次執行一行程式碼。然而像是點擊事件或是從 Javascript 取得資料，有 callback 函數可以執行，當事件或動作完成，因為 Javascript 是同步的，會怎麼處理非同步事件</p></article></a><a href="/2019/04/24/2019-04-24/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (11) - 範圍、ES6 與 let</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">執行環境、變數環境與詞彙環境定義了所謂的範圍，特別是在範圍鏈當中可看到每個函數都有一個外部環境。範圍就是變數可以被取用的區域。如果有兩個相同變數，如果呼叫相同函數 2 次，它會各有一個自己的執行環境，這兩個看起來相同的變數，在記憶體中其實是兩個不同的變數。
使用 let 及 const 宣告區塊變數在 ES6 當中，引進一種新的宣告變數方法 let 及 const。雖然它的使用方法與 var 相同，但並沒有取代後者。但是 let 讓 J</p></article></a><a href="/2019/04/23/2019-04-23/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (10) - 範圍鏈 Scope</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">當我們需要使用變數時，JavsScript 不只會在目前的執行環境的變數環境尋找。因為每個執行環境都會創造一個特殊的變數叫做 this 以及外部環境的參照。每個執行環境都有一個參照到他的外部環境。
在函式 b 的狀況，它的外部環境是全域執行環境，a 函式也是同樣狀況。即使 a 在執行堆中被壓在 b 下面，重點在於參照的究竟是哪種外部環境？
1234567891011function b() &amp;#123;  console.log(myV</p></article></a><a href="/2019/04/22/2019-04-22/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (9) 函數、環境與變數環境</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">變數環境(variable environments) 是另一個理解 Javascript 底層運作原理的基礎概念。變數環境就是指你創造變數的位置，以及他在記憶體中和其他變數的關係。因此在思考變數環境的時候，只要思考變數在哪裡。
變數環境有函式 a 及函式 b，函式 b 內宣告一變數 myVar，並且不設定值，函式 a 內設定變數 myVar=2，在函式外再次宣告 myVar＝1，接著呼叫函式 a，裡面逐行執行呼叫 b。 所以 myVa</p></article></a><a href="/2019/04/18/2019-04-18/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (8) 函數呼叫與執行堆</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">全域執行環境的創造與執行與和函式脫不了關係，函式呼叫與執行堆更是其中兩個重要環節。
在 Javascript 裡，只要是「函數名稱＋（）」就是執行或呼叫這個函數時，稱作 “invoke the function” 或 “function invocation”。但是 JavaScript 呼叫函數時發生什麼事情？
呼叫函式1234567function b() &amp;#123;&amp;#125;function a() &amp;#123;  b();&amp;</p></article></a><a href="/2019/04/17/2019-04-17/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (7) 單執行緒、同步執行</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">在學習 JavaScript 時，必須要知道它是單執行緒 (single threaded) ，也就是單線程。
可以理解成它一次只做一件事情。瀏覽器無論什麼時候，都只有一個單線程在執行 JavaScript。單執行緒單執行緒的意思是一次執行一個指令，可是在使用瀏覽器的時候，瀏覽器只分配給 JavaScript 一個主執行緒(stack)，用來執行任務（函式），但一次只能執行一個任務，這些任務形成一個事件佇列 (Queue) 排隊等候執行</p></article></a><a href="/2019/04/15/2019-04-15/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (6) 執行環境：程式執行</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 產生執行環境時，第一階段是創造，設定變數和函數到記憶體中。第二階段是執行。
1234567function b() &amp;#123;  console.log(&quot;called b!&quot;);&amp;#125;b();console.log(a);var a = &quot;hello world!&quot;;console.log(a);

上面的程式碼會得出什麼執行結果呢？

為什麼呢？ 因為現在已經是執行階段，首先先設定函數，接著變數 a 被</p></article></a><a href="/2019/04/13/2019-04-13/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (5) JavaScript 與 undefined</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">建立執行環境的第一階段「創造階段」，會在全域環境裡產生一個全域物件及一個特殊的變數 this；如果有外部環境，也會產生連結到外部環境的連結；以及「提昇」（hositing) 的特殊現象，為函數及變數在記憶體裡建立空間，此時變數的初始值被設定為 undefined。
12var a;console.log(a);

在瀏覽器查詢的結果會是 undefined

undefined 是什麼意思呢？undefined 其實是一種 Javasc</p></article></a><a href="/2019/04/12/2019-04-12/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (4) 創造與提昇</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 執行時，必經的創造執行環境的階段，究竟底層發生什麼變化？在下列的範例中，假如我們把呼叫移到程式碼最上方，移到函式之前：
123456b();console.log(a);var a = &quot;hello world&quot;;function b() &amp;#123;  console.log(&quot;called b !&quot;);&amp;#125;

在多數程式語言裡面，這，因為還沒宣告函式就先呼叫，所以呼叫是無效的。但 JavaScript </p></article></a><a href="/2019/04/10/2019-04-10/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (2) 名稱/值配對與物件</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">要理解 Javascript 當中非常重要的「物件」(Object)，首先要釐清名稱/值的配對。
一個執行環境底下，任何一段正在執行的程式碼，只會有一個單獨的名稱，不會有另一個相同的名稱，一個名稱只能定義一個值。但是這個值，還可以是另一個名稱/值的配對。
Javascript 最簡單的物件定義：物件就是名稱/值配對的組合。總歸而言，一個名稱只會配對一個值。
例如：
12345678Address:&amp;#123;    Street:'Ma</p></article></a><a href="/2019/04/10/2019-04-11/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (3) 全域環境與全域物件</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">Javascript 程式永遠都是在執行環境中運作，也就是透過解譯器 - 一個已經寫好的程式  - 驗證和執行你的程式碼。執行環境將正在執行的程式碼包裹在其中管理。
所以 JavaScript 的程式碼開始被運作的最初基礎，是執行環境的建立和執行。和其他被執行的程式碼不同，基礎執行環境是全域執行環境。全域是指可以在任何地方取用他。
即便一個 Javascript 檔案裡還沒有寫入任何程式碼、空的，但只要一旦載入，語法解析器開始運作，雖然</p></article></a><a href="/2019/04/01/2019-04-01/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript Weird Part (1) 語法解析器、執行環境、詞彙環境</h2><span class="post-meta"></span><p itemprop="text" class="post-excerpt">JavaScript 的運作原理，包含三項最基本的觀念：

語法解析器 (Syntax Parsers)
執行環境 (Execution Contexts)
詞彙環境 (Lexical Environments)

語法解析器語法解析器是什麼？如果 JavaScript 的程式碼使用有效的語法，就可被讀取且執行。但這不是程式碼直接告訴電腦怎麼執行，而是透過另一個程式「語法解析器」，把我們寫的 JavaScript 程式碼，逐字解讀成電腦</p></article></a></main></body></html>