<!DOCTYPE html><html lang="en.yml"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 克服 JavaScript 的奇怪部份 [Day36] - 立即呼叫的函數表示式 (IIFEs) · CYC'S BLOG</title><meta name="description" content="克服 JavaScript 的奇怪部份 [Day36] - 立即呼叫的函數表示式 (IIFEs) - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="CYC'S BLOG"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ChiangYuChi" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">克服 JavaScript 的奇怪部份 [Day36] - 立即呼叫的函數表示式 (IIFEs)</h1><div class="post-info">Aug 9, 2019</div><div class="post-content"><p>立即呼叫的函數表示式（immediately invoked function expression, IIFEs) 是一個常用的簡潔觀念。</p>
<p>先前我們已經知道函數陳述句和函數表達式的差異</p>
<h1 id="函數陳述句"><a href="#函數陳述句" class="headerlink" title="函數陳述句"></a>函數陳述句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet(name)&#123;</span><br><span class="line">console.log(&apos;Hello&apos; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JavaScript 即便把函數放到記憶體中還是不會執行任何東西，除非呼叫它</p>
<h1 id="函數表達式"><a href="#函數表達式" class="headerlink" title="函數表達式"></a>函數表達式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greetFunc = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>JavaScript 一開始不會把函數表示式部分被放進記憶體裡面，而是在執行該行程式碼的時候，<strong>立即地創造這個函數物件</strong>，然後可以使用指向該函式記憶體位置的變數呼叫它。</p>
<h1 id="立即呼叫的函數表達式-IIFE"><a href="#立即呼叫的函數表達式-IIFE" class="headerlink" title="立即呼叫的函數表達式 IIFE"></a>立即呼叫的函數表達式 IIFE</h1><p>既然我們是使用 <code>()</code> 呼叫函數，現在我們已經創造函數了，如果我們在<br>函數物件的尾巴加上一個括號 <code>()</code>，結果會如何呢？像這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name);</span><br><span class="line">&#125;)(); <span class="comment">// Hello undefined</span></span><br></pre></td></tr></table></figure>

<p>仿照之前帶入參數的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + name);</span><br><span class="line">&#125;)(<span class="string">"John"</span>); <span class="comment">// Hello John</span></span><br></pre></td></tr></table></figure>

<p>立即呼叫函數表達式(IIFE)的原理並不複雜，就是在創造函數的時候，立刻呼叫它。</p>
<h2 id="修改程式碼的其他觀察"><a href="#修改程式碼的其他觀察" class="headerlink" title="修改程式碼的其他觀察"></a>修改程式碼的其他觀察</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello"</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">//函數的程式碼內容</span></span><br></pre></td></tr></table></figure>

<p>會回傳 greeting 函數的內容<br><img src="https://i.imgur.com/c2qO1hy.png" alt><br>然後呼叫它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(greeting(&apos;John&apos;));</span><br></pre></td></tr></table></figure>

<p>得出預期的值</p>
<p><img src="https://i.imgur.com/KMYfTLA.png" alt></p>
<p>可是如果加入立即呼叫呢？會怎樣？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var greeting = function(name)&#123;</span><br><span class="line">return &apos;Hello&apos; + name;</span><br><span class="line">&#125;(&apos;John&apos;);</span><br><span class="line"></span><br><span class="line">console.log(greeting);</span><br></pre></td></tr></table></figure>

<p>函數表達式創造函數物件，接著立即呼叫，值會回傳給 <code>greeting</code>，
所以輸出 Hello John。</p>
<p>要注意的是 <code>greeting</code> 現在是一個字串不是函數了，所以如果試著呼叫它會報錯。這是因為函數物件創造後立刻執行回傳字串給<code>greeting</code></p>
<p><img src="https://i.imgur.com/IZlVmi3.png" alt></p>
<p>那為什麼剛剛的例子可以多次呼叫，可是不會變成字串呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greetFunc = function(name) &#123;</span><br><span class="line">  return &apos;Hello &apos; + name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(greetFunc(&apos;John&apos;));</span><br><span class="line">console.log(greetFunc(&apos;John&apos;));</span><br></pre></td></tr></table></figure>

<p>在這個例子因為，先前提到，一開始 JavaScript 並不會將函式的部分放入記憶體，而是在執行到該行程式碼時，立即地創造這個函式物件。</p>
<p>所以當執行到這一行時，</p>
<p>var greetFunc = function(name) {</p>
<p>因為只是創造匿名函式物件並沒有執行，所以此時的 greetFunc 變數的值指向匿名函式的記憶體位址。</p>
<h1 id="JavaScript-的表達式"><a href="#JavaScript-的表達式" class="headerlink" title="JavaScript 的表達式"></a>JavaScript 的表達式</h1><p>在 JavaScript 當中，以下都是有效的表達式，但沒有任何作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3;</span><br><span class="line">&apos;I am a string&apos;;</span><br><span class="line">&#123;</span><br><span class="line">name:&apos;John&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>數字、字串、物件都能像這樣直接使用表達式，那函式呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(name) &#123;</span><br><span class="line">     return &apos;Hello &apos; + name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/IOSH4Pv.png" alt></p>
<p>這是因為語法解析器看到 function 這個字，它預期應該是要使用函數陳述句，但卻缺少它所需要的名稱，函數陳述句不可以是匿名的，所以這個語法有問題。</p>
<p>但事實上我們所要的就只是不用其他變數，<strong>單獨讓函數表達式在這裡</strong>，那就確保語法解析器不要在程式碼的第一個字就碰到 function ？ 像這樣做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (name) &#123;</span><br><span class="line">    return &apos;Hello &apos; + name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>現在就不會報錯了，現在語法解析器知道這個包在括號內的函式不是陳述句了，而是表示式。因為括號在 JavaScript 是一個運算子，括號通常都是用在一些表示式上，像是 <code>(3+4)*2</code> 或是把一些東西群組起來。像是 if 這樣的陳述句就不會用到括號。JavaScript 引擎知道在括號裡的東西是表示式，他假設你寫的函數是函數表示式，你正在創造函數物件。</p>
<h2 id="進一步觀察"><a href="#進一步觀察" class="headerlink" title="進一步觀察"></a>進一步觀察</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function(name) &#123;</span><br><span class="line">var greeting = &quot;Hello&quot;;</span><br><span class="line">  console.log(&apos;Hello &apos; + name);</span><br><span class="line">&#125;)(&apos;Tony&apos;); //Hello Tony</span><br><span class="line"></span><br><span class="line">現在我們加入一點前面提到的觀念，直接呼叫它，這也是一個 IIFE。</span><br><span class="line">另外這也是 IIFE 最常見的一種樣子。</span><br><span class="line"></span><br><span class="line">(function(name) &#123;</span><br><span class="line">  console.log(&apos;Hello &apos; + name);</span><br><span class="line">&#125;(&apos;Tony&apos;)); //Hello Tony</span><br></pre></td></tr></table></figure>

<h1 id="IFFE-的用處"><a href="#IFFE-的用處" class="headerlink" title="IFFE 的用處"></a>IFFE 的用處</h1><p>我們知道 JavaScript 有全域執行環境、函式執行環境，直到 ES6 才出現塊級作用域(例如 let )，在 ES6 出來前，為了避免設定太多的全域變數，開發者往往會將變數設定在函式中，使其成為區域變數，尤其是設定在 IIFE 中，確保不會汙染到全域環境的變數。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &apos;Emma&apos;;</span><br><span class="line">(function(name) &#123;</span><br><span class="line">  var firstName = &apos;Doe&apos;;</span><br><span class="line">  console.log(&apos;Hello &apos; + name + &apos; &apos; + firstName);</span><br><span class="line">&#125;)(&apos;John&apos;); // Hello John Doe</span><br><span class="line"></span><br><span class="line">console.log(firstName); // Emma</span><br></pre></td></tr></table></figure>

<p>即使使用同樣的變數 firstName ，但 Doe 只存在於 IIFE 內，不會影響到外部環境的變數值 Emma</p>
<p>那如果反過來呢? IIFE 內想取用同樣名稱的變數值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &apos;Emma&apos;;</span><br><span class="line">(function(global) &#123;</span><br><span class="line">  var firstName = &apos;Doe&apos;;</span><br><span class="line">  console.log(&apos;Hello &apos; + firstName); // Hello Doe</span><br><span class="line">  console.log(&apos;Hello &apos; + global.firstName); // Hello Emma</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<p>也只需要把全域物件 window 傳入即可。</p>
<h1 id="經典實例"><a href="#經典實例" class="headerlink" title="經典實例"></a>經典實例</h1><p>這是一個蠻常看到的經典例子，主要是一些觀念的綜合題。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;執行第&apos; + i + &apos;次&apos;);</span><br><span class="line">  &#125;,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/KS5ljWE.png" alt></p>
<p>該如何修改才能正確地使執行第 i 次正確的輸出所有的 i 呢?</p>
<p>觀念是這樣的，因為寫在 for 迴圈內的 i 變數是使用 var 宣告的，而又沒有使用函式包覆，因此這個 i 是屬於全域執行環境下的全域變數。</p>
<p><img src="https://i.imgur.com/vAH9FM1.png" alt></p>
<p>然而寫在 setTimeout 內的匿名函式，因為沒有 i 變數，所以會轉而向外部環境尋找。</p>
<p><strong>setTimeout</strong><br>setTimeout 的作用就是把函式設定執行時間後，丟到事件佇列擱著。<br>for 迴圈是這樣處理 setTimeout 的：按照設定的方式，一次跑完，至於 setTimeout 的內容是什麼不管，以本例來說就是幾乎同時設定了 10 次 setTimeout。<br>所以才會在輸出幾乎同時看到「執行第 10 次」</p>
<h2 id="解法一：使用-let"><a href="#解法一：使用-let" class="headerlink" title="解法一：使用 let"></a>解法一：使用 let</h2><p>可以使用 ES6 新增的 let 輕鬆處理掉這個問題。因為 let 屬於區塊範圍 (Block Scope) ，變數僅存活於 {} 中，所以每次執行迴圈時取得的 i 在記憶體位址上都不同的，因此在 setTimeout 內的匿名函式參考到的 i 也都是不同的記憶體位址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;執行第&apos; + i + &apos;次&apos;);</span><br><span class="line">  &#125;,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/GdpG9ed.png" alt></p>
<h2 id="解法二：使用-IIFE"><a href="#解法二：使用-IIFE" class="headerlink" title="解法二：使用 IIFE"></a>解法二：使用 IIFE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">  (function(i) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&apos;執行第&apos; + i + &apos;次&apos;);</span><br><span class="line">    &#125;,10);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(window.i); // 10</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/S9wVybU.png" alt></p>
<p>透過 IIFE 建立個別的執行環境，讓傳入的 i 值每個都可以被保存，讓 setTimeout 內的匿名函式向外尋找變數 i 時會先找到 IIFE 內的，因此就不會被外部環境的 i 影響了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/08/06/2019-08-23-3/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'chiangyuchi';
var disqus_identifier = '2019/08/09/2019-08-23-2/';
var disqus_title = '克服 JavaScript 的奇怪部份 [Day36] - 立即呼叫的函數表示式 (IIFEs)';
var disqus_url = 'http://yoursite.com/2019/08/09/2019-08-23-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//chiangyuchi.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>