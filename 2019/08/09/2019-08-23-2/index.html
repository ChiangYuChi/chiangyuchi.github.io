<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>克服 JavaScript 的奇怪部份 [Day36] - 立即呼叫的函數表示式 (IIFEs) | CYC'S BLOG</title><meta name="description"><meta name="generator" content="CYC'S BLOG"><meta name="author" content="John Doe"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="CYC'S BLOG" title="CYC'S BLOG" itemprop="headline">CYC'S BLOG</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline" class="post-heading">克服 JavaScript 的奇怪部份 [Day36] - 立即呼叫的函數表示式 (IIFEs)</h1><span class="page-tag-anchor"><a href="/tags/JavaScript" itemprop="url">#JavaScript
&nbsp;&nbsp;</a></span><span class="page-tag-anchor"><a href="/tags/前端學習" itemprop="url">#前端學習
&nbsp;&nbsp;</a></span><span class="page-tag-anchor"><a href="/tags/克服Javascript奇怪部份" itemprop="url">#克服Javascript奇怪部份
&nbsp;&nbsp;</a></span><span class="post-meta"></span><br><br><p>立即呼叫的函數表示式（immediately invoked function expression, IIFEs) 是一個常用的簡潔觀念。</p>
<p>先前我們已經知道函數陳述句和函數表達式的差異</p>
<h1 id="函數陳述句"><a href="#函數陳述句" class="headerlink" title="函數陳述句"></a>函數陳述句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet(name)&#123;</span><br><span class="line">console.log(&apos;Hello&apos; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JavaScript 即便把函數放到記憶體中還是不會執行任何東西，除非呼叫它</p>
<h1 id="函數表達式"><a href="#函數表達式" class="headerlink" title="函數表達式"></a>函數表達式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greetFunc = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>JavaScript 一開始不會把函數表示式部分被放進記憶體裡面，而是在執行該行程式碼的時候，<strong>立即地創造這個函數物件</strong>，然後可以使用指向該函式記憶體位置的變數呼叫它。</p>
<h1 id="立即呼叫的函數表達式-IIFE"><a href="#立即呼叫的函數表達式-IIFE" class="headerlink" title="立即呼叫的函數表達式 IIFE"></a>立即呼叫的函數表達式 IIFE</h1><p>既然我們是使用 <code>()</code> 呼叫函數，現在我們已經創造函數了，如果我們在<br>函數物件的尾巴加上一個括號 <code>()</code>，結果會如何呢？像這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + name);</span><br><span class="line">&#125;)(); <span class="comment">// Hello undefined</span></span><br></pre></td></tr></table></figure>

<p>仿照之前帶入參數的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + name);</span><br><span class="line">&#125;)(<span class="string">"John"</span>); <span class="comment">// Hello John</span></span><br></pre></td></tr></table></figure>

<p>立即呼叫函數表達式(IIFE)的原理並不複雜，就是在創造函數的時候，立刻呼叫它。</p>
<h2 id="修改程式碼的其他觀察"><a href="#修改程式碼的其他觀察" class="headerlink" title="修改程式碼的其他觀察"></a>修改程式碼的其他觀察</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello"</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">//函數的程式碼內容</span></span><br></pre></td></tr></table></figure>

<p>會回傳 greeting 函數的內容<br><img src="https://i.imgur.com/c2qO1hy.png" alt><br>然後呼叫它</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(greeting(<span class="string">"John"</span>));</span><br></pre></td></tr></table></figure>

<p>得出預期的值</p>
<p><img src="https://i.imgur.com/KMYfTLA.png" alt></p>
<p>可是如果加入立即呼叫呢？會怎樣？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello"</span> + name;</span><br><span class="line">&#125;)(<span class="string">"John"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting);</span><br></pre></td></tr></table></figure>

<p>函數表達式創造函數物件，接著立即呼叫，值會回傳給 <code>greeting</code>，
所以輸出 Hello John。</p>
<p>要注意的是 <code>greeting</code> 現在是一個字串不是函數了，所以如果試著呼叫它會報錯。這是因為函數物件創造後立刻執行回傳字串給<code>greeting</code></p>
<p><img src="https://i.imgur.com/IZlVmi3.png" alt></p>
<p>那為什麼剛剛的例子可以多次呼叫，可是不會變成字串呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greetFunc = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greetFunc(<span class="string">"John"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(greetFunc(<span class="string">"John"</span>));</span><br></pre></td></tr></table></figure>

<p>在這個例子因為，先前提到，一開始 JavaScript 並不會將函式的部分放入記憶體，而是在執行到該行程式碼時，立即地創造這個函式物件。</p>
<p>所以當執行到這一行時，</p>
<p>var greetFunc = function(name) {</p>
<p>因為只是創造匿名函式物件並沒有執行，所以此時的 greetFunc 變數的值指向匿名函式的記憶體位址。</p>
<h1 id="JavaScript-的表達式"><a href="#JavaScript-的表達式" class="headerlink" title="JavaScript 的表達式"></a>JavaScript 的表達式</h1><p>在 JavaScript 當中，以下都是有效的表達式，但沒有任何作用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>;</span><br><span class="line">(<span class="string">"I am a string"</span>);</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">"John"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>數字、字串、物件都能像這樣直接使用表達式，那函式呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">'Hello '</span> + name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/IOSH4Pv.png" alt></p>
<p>這是因為語法解析器看到 function 這個字，它預期應該是要使用函數陳述句，但卻缺少它所需要的名稱，函數陳述句不可以是匿名的，所以這個語法有問題。</p>
<p>但事實上我們所要的就只是不用其他變數，<strong>單獨讓函數表達式在這裡</strong>，那就確保語法解析器不要在程式碼的第一個字就碰到 function ？ 像這樣做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>現在就不會報錯了，現在語法解析器知道這個包在括號內的函式不是陳述句了，而是表示式。因為括號在 JavaScript 是一個運算子，括號通常都是用在一些表示式上，像是 <code>(3+4)*2</code> 或是把一些東西群組起來。像是 if 這樣的陳述句就不會用到括號。JavaScript 引擎知道在括號裡的東西是表示式，他假設你寫的函數是函數表示式，你正在創造函數物件。</p>
<h2 id="進一步觀察"><a href="#進一步觀察" class="headerlink" title="進一步觀察"></a>進一步觀察</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">&#125;)(<span class="string">'Tony'</span>); <span class="comment">//Hello Tony</span></span><br><span class="line"></span><br><span class="line">現在我們加入一點前面提到的觀念，直接呼叫它，這也是一個 IIFE。</span><br><span class="line">另外這也是 IIFE 最常見的一種樣子。</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">&#125;(<span class="string">'Tony'</span>)); <span class="comment">//Hello Tony</span></span><br></pre></td></tr></table></figure>

<h1 id="IFFE-的用處"><a href="#IFFE-的用處" class="headerlink" title="IFFE 的用處"></a>IFFE 的用處</h1><p>我們知道 JavaScript 有全域執行環境、函式執行環境，直到 ES6 才出現塊級作用域(例如 let )，在 ES6 出來前，為了避免設定太多的全域變數，開發者往往會將變數設定在函式中，使其成為區域變數，尤其是設定在 IIFE 中，確保不會汙染到全域環境的變數。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">"Emma"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstName = <span class="string">"Doe"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + name + <span class="string">" "</span> + firstName);</span><br><span class="line">&#125;)(<span class="string">"John"</span>); <span class="comment">// Hello John Doe</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstName); <span class="comment">// Emma</span></span><br></pre></td></tr></table></figure>

<p>即使使用同樣的變數 firstName ，但 Doe 只存在於 IIFE 內，不會影響到外部環境的變數值 Emma</p>
<p>那如果反過來呢? IIFE 內想取用同樣名稱的變數值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">"Emma"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstName = <span class="string">"Doe"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + firstName); <span class="comment">// Hello Doe</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + global.firstName); <span class="comment">// Hello Emma</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>也只需要把全域物件 window 傳入即可。</p>
<h1 id="經典實例"><a href="#經典實例" class="headerlink" title="經典實例"></a>經典實例</h1><p>這是一個蠻常看到的經典例子，主要是一些觀念的綜合題。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"執行第"</span> + i + <span class="string">"次"</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/KS5ljWE.png" alt></p>
<p>該如何修改才能正確地使執行第 i 次正確的輸出所有的 i 呢?</p>
<p>觀念是這樣的，因為寫在 for 迴圈內的 i 變數是使用 var 宣告的，而又沒有使用函式包覆，因此這個 i 是屬於全域執行環境下的全域變數。</p>
<p><img src="https://i.imgur.com/vAH9FM1.png" alt></p>
<p>然而寫在 setTimeout 內的匿名函式，因為沒有 i 變數，所以會轉而向外部環境尋找。</p>
<p><strong>setTimeout</strong><br>setTimeout 的作用就是把函式設定執行時間後，丟到事件佇列擱著。<br>for 迴圈是這樣處理 setTimeout 的：按照設定的方式，一次跑完，至於 setTimeout 的內容是什麼不管，以本例來說就是幾乎同時設定了 10 次 setTimeout。<br>所以才會在輸出幾乎同時看到「執行第 10 次」</p>
<h2 id="解法一：使用-let"><a href="#解法一：使用-let" class="headerlink" title="解法一：使用 let"></a>解法一：使用 let</h2><p>可以使用 ES6 新增的 let 輕鬆處理掉這個問題。因為 let 屬於區塊範圍 (Block Scope) ，變數僅存活於 {} 中，所以每次執行迴圈時取得的 i 在記憶體位址上都不同的，因此在 setTimeout 內的匿名函式參考到的 i 也都是不同的記憶體位址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;執行第&apos; + i + &apos;次&apos;);</span><br><span class="line">  &#125;,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/GdpG9ed.png" alt></p>
<h2 id="解法二：使用-IIFE"><a href="#解法二：使用-IIFE" class="headerlink" title="解法二：使用 IIFE"></a>解法二：使用 IIFE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">  (function(i) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&apos;執行第&apos; + i + &apos;次&apos;);</span><br><span class="line">    &#125;,10);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(window.i); // 10</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/S9wVybU.png" alt></p>
<p>透過 IIFE 建立個別的執行環境，讓傳入的 i 值每個都可以被保存，讓 setTimeout 內的匿名函式向外尋找變數 i 時會先找到 IIFE 內的，因此就不會被外部環境的 i 影響了。</p>
</article><br><br><span class="next-post"><a href="/2019/08/06/2019-08-23-3/" itemprop="url">Older Post ⇒</a></span><span class="prev-post"><a href="/2019/09/22/2019-09-22/" itemprop="url">⇐ Next Post </a></span><br><br><br></main></body></html>