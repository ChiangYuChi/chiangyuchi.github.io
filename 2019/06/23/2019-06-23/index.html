<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Get API 實作 | CYC'S BLOG</title><meta name="description"><meta name="generator" content="CYC'S BLOG"><meta name="author" content="John Doe"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="CYC'S BLOG" title="CYC'S BLOG" itemprop="headline">CYC'S BLOG</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline" class="post-heading">Get API 實作</h1><span class="page-tag-anchor"><a href="/tags/JavaScript" itemprop="url">#JavaScript
&nbsp;&nbsp;</a></span><span class="page-tag-anchor"><a href="/tags/前端學習" itemprop="url">#前端學習
&nbsp;&nbsp;</a></span><span class="post-meta"></span><br><br><p>這一篇主要是整理一個 Get API 小作品的思路。因為是參考別人的解法，加上自己的思考慣性是習慣從頭到尾把細節了解一次才認為完整掌握，所以使用這種看起來笨笨的步驟，一句一句拆解。</p>
<p>完成品 <a href="https://chiangyuchi.github.io/get-api" target="_blank" rel="noopener">https://chiangyuchi.github.io/get-api</a><br>原始碼 <a href="https://github.com/ChiangYuChi/get-api" target="_blank" rel="noopener">https://github.com/ChiangYuChi/get-api</a></p>
<h3 id="設定-DOM"><a href="#設定-DOM" class="headerlink" title="設定 DOM"></a>設定 DOM</h3><ul>
<li>select  區域選單</li>
<li>degreetable </li>
<li>placeTitle 區域名稱</li>
<li>time 更新時間</li>
<li>detail 細節</li>
<li>detailTitle</li>
<li>infoList 清單</li>
</ul>
<h3 id="取得資料"><a href="#取得資料" class="headerlink" title="取得資料"></a>取得資料</h3><ul>
<li>fetch open data </li>
<li>怎麼解決CROS問題 (cros-anywhere)</li>
<li>fetch 之後要怎麼存？存在哪裡？這些數據要幹嘛？<pre><code>-連結get data 函式，儲存data
-更新所有頁面，先放入NTP。( datail, infoList) 
-待資料渲染至頁面後，關閉 loading page&gt;loading.style.display=&apos;none&apos;;</code></pre></li>
</ul>
<h3 id="綁定事件"><a href="#綁定事件" class="headerlink" title="綁定事件"></a>綁定事件</h3><ul>
<li>表單切換 change 事件<br>切換之後把點擊對象的值（e.target.value)，渲染到整個頁面 (updateAll)</li>
<li>項目 click 事件，如果點擊的標的是連結(e.target.value==A)，把連結標的的值，更新到細節欄位</li>
</ul>
<h3 id="儲存色彩資訊"><a href="#儲存色彩資訊" class="headerlink" title="儲存色彩資訊"></a>儲存色彩資訊</h3><ul>
<li>把顏色整理成陣列</li>
<li>顏色加入等級表，用for迴圈</li>
</ul>
<h3 id="取得資料後的儲存"><a href="#取得資料後的儲存" class="headerlink" title="取得資料後的儲存"></a>取得資料後的儲存</h3><ul>
<li><p>getData函式，儲存data為陣列<br>把data裡面待會要存到選單項裡面的，用迴圈以add方法，把需要的內容（需要哪些？），向new Set()結構加入新成員。</p>
</li>
<li><p>儲存的資料以location的名稱運用在加入選單所需的參數</p>
<h3 id="加入選單"><a href="#加入選單" class="headerlink" title="加入選單"></a>加入選單</h3></li>
<li><p>加入選單的函式（有一個參數location)</p>
</li>
<li><p>用forEach方法，巡訪參數的每個元素</p>
</li>
<li><p>以名為option的變數，創建元素</p>
</li>
<li><p>設置指定元素上element的属性值。如果属性已经存在，则更新该值；否则，使  用指定的名称和值添加一个新的属性。</p>
</li>
<li><p>把創建的元素加入option</p>
</li>
<li><p>把新增的option加進select</p>
<h3 id="完成的選單被變更了，觸發-change-事件"><a href="#完成的選單被變更了，觸發-change-事件" class="headerlink" title="完成的選單被變更了，觸發 change 事件"></a>完成的選單被變更了，觸發 change 事件</h3></li>
<li><p>updateAll（location) 傳入的參數是被點擊的地點</p>
</li>
<li><p>被點擊的地點，已經用location儲存，現在取用這個location</p>
</li>
<li><p>要在畫面更新的地區抬頭，就是點擊地點</p>
</li>
<li><p>要在畫面更新的時間，就取用第一筆陣列資料的發佈時間＋’更新’</p>
</li>
<li><p>要更新畫面，先把整個infoList清空</p>
</li>
<li><p>宣告一個非全域變數 data，它的值的取得，是在datalist裡一個一個過濾所有項目，如果過濾的項目裡面，有任何一個等於我所在區域的項目，回傳項目。</p>
</li>
<li><p>剛剛過濾出的項目儲存在變數data裡面，宣告一個新變數sortedData=data，並且用AQI大小排序</p>
</li>
<li><p>排序過的資料，用forEach，以字串形式置入畫面</p>
</li>
<li><p>在arrow function 裡，每個被檢查到的data，都當做el參數傳入</p>
</li>
<li><p>宣告一個新的變數叫做 newList，以此創建一個新的元素li</p>
</li>
<li><p>如果傳入的參數的AQI是空值或hypen，他們的AQI就等於N/A</p>
</li>
<li><p>宣告一個新的變數叫colorList，它的值是在colors陣列裡面比對，find 方法會對每個元素執行一次 callback 函式，直到找到一個讓 callback 函式回傳 true 的元素。當元素被找到的時候，find 會立刻回傳該元素，否則 find 會回傳 undefined。這個陣列裡面比對的狀態，當成col參數在這個方法裡運作，比對傳入元素的狀態，如果符合，就回傳色彩。</p>
</li>
<li><p>如果資料內沒有status(設備維修),if(colorList==undefined)，套用顏色是 ＃EEEEEE</p>
</li>
<li><p>組字串，並且更新：字串包含</p>
<p>  最外層的inforBox<br>  新增一個連結它的顯示文字是傳入的參數的siteName<br>  新增傳入元素的AQI，它的顏色是在colorList陣列裡面用status比對 的色彩</p>
</li>
<li><p>把字串加入newList裡</p>
</li>
<li><p>把newList加入父階層infoList</p>
</li>
<li><p>同步更新detail, updateDetail(傳入參數排序第一個的站名)</p>
</li>
</ul>
<h3 id="更新detail"><a href="#更新detail" class="headerlink" title="更新detail"></a>更新detail</h3><ul>
<li>函數傳入的參數就是我點擊的那一個</li>
<li>那一個要更新在畫面上的項目，是在資料陣列裡面用find()方法尋找的，並且叫它place</li>
<li>如果點擊的那一個，符合資料陣列裡面的siteName，就把data傳入一個新的空陣列裡面</li>
<li>空陣列包含 item.O3, item.PM10, item[‘PM2.5’], item.CO, item.SO2, item.NO2</li>
<li>細節標題的第一項，更新成上面的place</li>
<li>細節標題的第二項，就是項目的AQI屬性</li>
<li>著色的方式同上，宣告一個新的變數叫colorList，它的值是在colors陣列裡面比對，find 方法會對每個元素執行一次 callback 函式，直到找到一個讓 callback 函式回傳 true 的元素。當元素被找到的時候，find 會立刻回傳該元素，否則 find 會回傳 undefined。這個陣列裡面比對的狀態，當成col參數在這個方法裡運作，比對傳入元素的狀態，如果符合，就回傳色彩。所以要判斷這個colorlist的status是否等於傳入的項目的status，如果是，就回傳。</li>
<li>回傳顏色的運用方式，是將細節的第一個的背景顏色，比對colorList。</li>
<li>把data內的資料更新至 detail上 （用迴圈的方式，去檢查數據的長度，並且依照索引值一個一個放到細節項目的相同索引值位置，並回傳）</li>
</ul>
</article><br><br><span class="next-post"><a href="/2019/06/22/2019-06-22/" itemprop="url">Older Post ⇒</a></span><span class="prev-post"><a href="/2019/06/24/2019-06-24/" itemprop="url">⇐ Next Post </a></span><br><br><br></main></body></html>